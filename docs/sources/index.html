<!DOCTYPE html>
<html class="style-dark">
  <head>
    <title>CompoundJS - build apps with love</title>
    <link rel="stylesheet" href="stylesheets/application.css">
    <link rel="stylesheet" href="stylesheets/prettify.css">
    <link href="http://fonts.googleapis.com/css?family=Quicksand:300" rel="stylesheet">
    <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
    <script src="javascripts/jquery.scrollspy.js"></script>
    <script src="javascripts/prettyprint.js"></script>
    <script src="javascripts/application.js"></script>
  </head>
  <body>
    <div class="sidebar">
      <div class="menu"></div>
      <ul class="items"></ul>
    </div>
    <div class="content-wrapper"><img src="images/logo.png" alt="CompoundJS" class="logo">
      <div class="style-switch"></div>
      <section id="routing-routing">
<h1>Routing</h1>

<p>
The purpose of routes is to connect a URL with a controller action. For example,
you can define the following route in <code>config/routes.js</code> to link <code>GET /signup</code>
with <code>new</code> action of <code>users</code> controller:

</p>

<pre class="prettyprint">
map.get('signup', 'users#new');
</pre>

<p>
The following route will link <code>GET /</code> to the <code>index</code> action of the<code>home</code> controller:

</p>

<pre class="prettyprint">
map.root('home#index');
</pre>

</section>

<section id="routing-url-helpers">
<h2>URL helpers</h2>

<p>
Another useful feature of routes: URL helpers. When you define route

</p>

<pre class="prettyprint">
map.get('bunny', 'bunny#show');
</pre>

<p>
you can use <code>pathTo.bunny</code> in your controllers and views, which will generate

</p>

<pre class="prettyprint">
/bunny
</pre>

<p>
path for you. You also can specify another helper name is you want:

</p>

<pre class="prettyprint">
map.get('bunny', 'bunny#show', {as: 'rabbit'});
</pre>

<p>
and now <code>pathTo.rabbit</code> available.

</p>

<p>
If your route has param, for example

</p>

<pre class="prettyprint">
map.get('profile/:user', 'users#show');
map.get('posts/:post_id/comments/:comment_id', 'comments#show');
</pre>

<p>
URL helper will accept parameter (String), so that:

</p>

<pre class="prettyprint">
pathTo.profile('Bugs_Bunny', 'users#show');
&gt; '/profile/Bugs_Bunny'
pathTo.post_comment(2, 2383);
&gt; '/posts/2/comments/2383'
</pre>

<blockquote>
<p>
<strong>Why use URL helpers?</strong><br/>
First of all it's convenient and beauty. But what is more important
url helpers take care about namespaces. In case if your application will be
used as part of another application, mounted on some URL like "/foreign-app"
URL helpers will return correct value: "/foreign-app/profile/Bugs_Bunny"
instead of "/profile/Bugs_Bunny"
</p>
</blockquote>

<p>
How to learn what helper name was generated? Read "Debugging" section.

</p>

</section>

<section id="routing-debugging">
<h2>Debugging</h2>

<p>
To debug routes of your compound application you can use <code>compound routes</code>
command (or shortcut <code>compound r</code>). You can also specify optional argument for
filtering by helper name or method, for example:

</p>

<pre class="prettyprint">
~: ) compound r post
     posts GET    /posts.:format?          posts#index
     posts POST   /posts.:format?          posts#create
  new_post GET    /posts/new.:format?      posts#new
 edit_post GET    /posts/:id/edit.:format? posts#edit
      post DELETE /posts/:id.:format?      posts#destroy
      post PUT    /posts/:id.:format?      posts#update
      post GET    /posts/:id.:format?      posts#show
~: ) compound r GET
     posts GET    /posts.:format?          posts#index
  new_post GET    /posts/new.:format?      posts#new
 edit_post GET    /posts/:id/edit.:format? posts#edit
      post GET    /posts/:id.:format?      posts#show
~: ) compound r new
 new_post GET    /posts/new.:format? posts#new
</pre>

</section>

<section id="routing-resources">
<h2>Resources</h2>

<p>
Resource-based routing provides standard mapping between HTTP verbs and controller actions:

</p>

<pre class="prettyprint">
map.resources('posts');
</pre>

<p>
will provide the following routes:

</p>

<pre class="prettyprint">
  helper | method | path                   | controller#action
    posts GET      /posts                   posts#index
    posts POST     /posts                   posts#create
 new_post GET      /posts/new               posts#new
edit_post GET      /posts/:id/edit          posts#edit
     post DELETE   /posts/:id               posts#destroy
     post PUT      /posts/:id               posts#update
     post GET      /posts/:id               posts#show.
</pre>

<p>
To list all available routes you can run the command <code>compound routes</code>.

</p>

<p>
The first column of the table represents the <code>helper</code> - you can use this identifier in views and controllers to get the route. Some examples:

</p>

<pre class="prettyprint">
path_to.new_post            # /posts/new
path_to.edit_post(1)        # /posts/1/edit
path_to.edit_post(post)     # /posts/1/edit (in this example post = {id: 1})
path_to.posts               # /posts
path_to.post(post)          # /posts/1.
</pre>

</section>

<section id="routing-options">
<h3>Options</h3>

<p>
If you want to override default routes behaviour, you can use two options: <code>as</code> and <code>path</code> to specify a helper name and a path you want to have in the result.

</p>

<p>
<strong>
{ as: 'helperName' }
</strong>

</p>

<p>
Path helper aliasing:

</p>

<pre class="prettyprint">
map.resources('posts', { as: 'articles' });
</pre>

<p>
This will create the following routes:

</p>

<pre class="prettyprint">
    articles GET    /posts.:format?          posts#index
    articles POST   /posts.:format?          posts#create
 new_article GET    /posts/new.:format?      posts#new
edit_article GET    /posts/:id/edit.:format? posts#edit
     article DELETE /posts/:id.:format?      posts#destroy
     article PUT    /posts/:id.:format?      posts#update
     article GET    /posts/:id.:format?      posts#show.
</pre>

<p>
<strong>
{ path: 'alternatePath' }
</strong>

</p>

<p>
If you want to change the base path:

</p>

<pre class="prettyprint">
map.resources('posts', { path: 'articles' });
</pre>

<p>
This will create the following routes:

</p>

<pre class="prettyprint">
    posts GET    /articles.:format?          posts#index
    posts POST   /articles.:format?          posts#create
 new_post GET    /articles/new.:format?      posts#new
edit_post GET    /articles/:id/edit.:format? posts#edit
     post DELETE /articles/:id.:format?      posts#destroy
     post PUT    /articles/:id.:format?      posts#update
     post GET    /articles/:id.:format?      posts#show
</pre>

<p>
<strong>
Both "as" and "path" together
</strong>

</p>

<p>
If you want to alias both the helper and the path:

</p>

<pre class="prettyprint">
map.resources('posts', { path: 'articles', as: 'stories' });
</pre>

<p>
This will create the following routes:

</p>

<pre class="prettyprint">
   stories GET    /articles.:format?          posts#index
   stories POST   /articles.:format?          posts#create
 new_story GET    /articles/new.:format?      posts#new
edit_story GET    /articles/:id/edit.:format? posts#edit
     story DELETE /articles/:id.:format?      posts#destroy
     story PUT    /articles/:id.:format?      posts#update
     story GET    /articles/:id.:format?      posts#show
</pre>

</section>

<section id="routing-nested-resources">
<h2>Nested resources</h2>

<p>
Some resources may have nested sub-resources, for example <code>Post</code> has many <code>Comments</code>, and of course we want to get a post's comments using <code>GET /post/1/comments</code>.

</p>

<p>
Let's describe the route for our nested resource:

</p>

<pre class="prettyprint">
map.resources('post', function (post) {
  post.resources('comments');
});.
</pre>

<p>
This routing map will provide the following routes:

</p>

<pre class="prettyprint">
$ compound routes
     post_comments GET      /posts/:post_id/comments          comments#index
     post_comments POST     /posts/:post_id/comments          comments#create
  new_post_comment GET      /posts/:post_id/comments/new      comments#new
 edit_post_comment GET      /posts/:post_id/comments/:id/edit comments#edit
      post_comment DELETE   /posts/:post_id/comments/:id      comments#destroy
      post_comment PUT      /posts/:post_id/comments/:id      comments#update
      post_comment GET      /posts/:post_id/comments/:id      comments#show
             posts GET      /posts                            posts#index
             posts POST     /posts                            posts#create
          new_post GET      /posts/new                        posts#new
         edit_post GET      /posts/:id/edit                   posts#edit
              post DELETE   /posts/:id                        posts#destroy
              post PUT      /posts/:id                        posts#update
              post GET      /posts/:id                        posts#show.
</pre>

</section>

<section id="routing-using-url-helpers-for-nested-routes">
<h3>Using url helpers for nested routes</h3>

<p>
To use routes like <code>post_comments</code> you should call helper with param: parent resource or identifier before nested resource:

</p>

<pre class="prettyprint">
path_to.post_comments(post)               # /posts/1/comments
path_to.edit_post_comment(post, comment)  # /posts/1/comments/10/edit
path_to.edit_post_comment(2, 300)         # /posts/2/comments/300/edit
</pre>

</section>

<section id="routing-namespaces">
<h2>Namespaces</h2>

<p>
You may wish to organize groups of controllers under a namespace. The most common use-case is an administration area. All controllers within the <code>admin</code> namespace should be located inside the <code>app/controllers/</code> directory.

</p>

<p>
For example, let's create an admin namespace:

</p>

<pre class="prettyprint">
map.namespace('admin', function (admin) {
  admin.resources('users');
});
</pre>

<p>
This routing rule will match with <code>/admin/users</code>, <code>/admin/users/new</code> and will create appropriate url helpers:

</p>

<pre class="prettyprint">
    admin_users GET    /admin/users.:format?          admin/users#index
    admin_users POST   /admin/users.:format?          admin/users#create
 new_admin_user GET    /admin/users/new.:format?      admin/users#new
edit_admin_user GET    /admin/users/:id/edit.:format? admin/users#edit
     admin_user DELETE /admin/users/:id.:format?      admin/users#destroy
     admin_user PUT    /admin/users/:id.:format?      admin/users#update
     admin_user GET    /admin/users/:id.:format?      admin/users#show
</pre>

</section>

<section id="routing-restricting-routes">
<h2>Restricting routes</h2>

<p>
If you need routes only for several actions (e.g. <code>index</code>, <code>show</code>), you can specify the <code>only</code> option:

</p>

<pre class="prettyprint">
map.resources('users', { only: ['index', 'show'] });
</pre>

<p>
If you want to have all routes except a specific route, you can specify the <code>except</code> option:

</p>

<pre class="prettyprint">
map.resources('users', { except: ['create', 'destroy'] });
</pre>

</section>

<section id="routing-custom-actions-in-resourceful-routes">
<h2>Custom actions in resourceful routes</h2>

<p>
If you need some specific action to be added to your resource-based route, use this example:

</p>

<pre class="prettyprint">
map.resource('users', function (user) {
  user.get('avatar', 'users#avatar');               // /users/:user_id/avatar
  user.get('top', 'users#top', {collection: true}); // /users/top
});
</pre>

</section>

<section id="routing-middleware">
<h2>Middleware</h2>

<p>
You may want to use middleware in routes. It's not recommended, but if you need
it you can put it as second argument:

</p>

<pre class="prettyprint">
map.get('/admin', authenticate, 'admin#index');
map.get('/protected/resource', [ middleware1, middleware2 ], 'resource#access');
</pre>

</section>

<section id="routing-subdomain">
<h2>Subdomain</h2>

<p>
**experimental**

</p>

<p>
If you want to support subdomain filter, specify it as <code>subdomain</code> option:

</p>

<pre class="prettyprint">
map.get('/url', 'ctl#action', {subdomain: 'subdomain.tld'});
</pre>

<p>
use \* as wildcard domain

</p>

<pre class="prettyprint">
map.get('/url', 'ctl#action', {subdomain: '*.example.com'});
</pre>

<p>
This feature relies on <code>host</code> header, if your node process behind nginx or proxy,
make sure you've passed this header to process.

</p>

</section>

<section id="controllers-controllers">
<h1>Controllers</h1>

<p>
In CompoundJS, a controller is a module that receives user input and initiates a response. Controllers consists of a set of actions. Each action is called by the request of a particular route. To define an action, you should use the reserved global function <code>action</code>.

</p>

</section>

<section id="controllers-features-overview">
<h2>Features overview</h2>

<p>
Inside controller you can use following reserved global functions to control response:

</p>

<ul>
<li><strong>render</strong> - render view template related to this action</li>
<li><strong>send</strong> - send text, status code or json object to client</li>
<li><strong>redirect</strong> - redirect client to specific location</li>
<li><strong>header</strong> - send header to client</li>
<li><strong>flash</strong> - display flash message</li>
</ul>
<p>
And here is a bunch of functions to control execution flow:

</p>

<ul>
<li><strong>before</strong> - invoke this method before any action</li>
<li><strong>after</strong> - invoke this method after any action</li>
<li><strong>load</strong> - load another controller to use its methods</li>
<li><strong>use</strong> or <strong>export</strong> - get method defined in another controller, loaded using `load`</li>
<li><strong>publish</strong> or <strong>import</strong> - allow method to be used in other controller</li>
</ul>
<p>
Let's learn more about each of this functions

</p>

</section>

<section id="controllers-response-control">
<h2>Response control</h2>

<p>
<code>NOTE: Each action should invoke exactly one output method. This is the only requirement imposed by the asynchronous nature of Node.js. If you don't call an output method, the client will infinitely wait for a server response.</code>

</p>

</section>

<section id="controllers-render">
<h3>render()</h3>

<p>
The <code>render</code> method accepts 0, 1 or 2 arguments. When called without any arguments, it just renders the view associated with this action. For example, this will render <code>app/views/posts/index.ejs</code>.

</p>

<code>posts_controller.js</code><pre class="prettyprint">
action('index', function () {
  render();
});
</pre>

<p>
If you want to pass some data to the view, there are two ways to do it. First is to simply pass a hash containing the data:

</p>

<pre class="prettyprint">
action('index', function () {
  render({ title: "Posts index" });
});
</pre>

<p>
and the second method is to set the properties of <code>this</code>:

</p>

<pre class="prettyprint">
action('index', function () {
  this.title = "Posts index";
  render();
});
</pre>

<p>
And if you want to render another view, just put its name as the first argument:

</p>

<pre class="prettyprint">
action('update', function () {
  this.title = "Update post";
  render('edit');
});
</pre>

<p>
or:

</p>

<pre class="prettyprint">
action('update', function () {
  render('edit', { title: "Update post" });
});
</pre>

</section>

<section id="controllers-send">
<h3>send()</h3>

<p>
The <code>send</code> function is useful for debugging and one-page apps where you don't want to render a heavy template and just want to send text or JSON data.

</p>

<p>
This function can be called with number (status code):

</p>

<pre class="prettyprint">
action('destroy', function () {
  send(403); // client will receive statusCode = 403 Forbidden
});
</pre>

<p>
or with a string:

</p>

<pre class="prettyprint">
action('sayHello', function () {
  send('Hello!'); // client will receive 'Hello!'
});
</pre>

<p>
or with object:

</p>

<pre class="prettyprint">
action('apiCall', function () {
  send({ hello: 'world' }); // client will receive '{"hello":"world"}'
});
</pre>

</section>

<section id="controllers-redirect">
<h3>redirect()</h3>

<p>
This function just sets the status code and <code>Location</code> header, so the client will be redirected to another location.

</p>

<pre class="prettyprint">
redirect('/'); // root redirection
redirect('http://example.com'); // redirect to another host
</pre>

</section>

<section id="controllers-flash">
<h3>flash()</h3>

<p>
The <code>flash</code> function stores a message in the session for future displaying, this is a regular expressjs function, refer to <a href="http://expressjs.com/2x/guide.html#req.flash%28%29 "Expressjs 2.0 guide"" target="_blank">expressjs 2.0 guide</a> to learn how it works. Few examples:

</p>

<code>posts_controller.js</code><pre class="prettyprint">
action('create', function () {
    Post.create(req.body, function (err) {
        if (err) {
            flash('error', 'Error while post creation');
            render('new', {post: req.body});
        } else {
            flash('info', 'Post has been successfully created');
            redirect(path_to.posts);
        }
    });
});
</pre>

<p>
This <code>create</code> action sends a flash info on success and a flash error on fail.

</p>

</section>

<section id="controllers-execution-flow-control">
<h2>Execution flow control</h2>

<p>
To provide the ability of DRY-ing controller code and reusing common code parts, CompoundJS provides a few additional tools: method chaining and external controllers loading.

</p>

<p>
To chain methods, you can use the <code>before</code> and<code>after</code> methods.

</p>

<code>checkout_controller.js</code><pre class="prettyprint">
before(userRequired, { only: 'order' });
before(prepareBasket, { except: 'order' });
before(loadProducts, { only: ['products', 'featuredProducts'] });

action('products', function () { ... });
action('featuredProducts', function () { ... });
action('order', function () { ... });
action('basket', function () { ... });

function userRequired () { next() }
function prepareBasket () { next() }
function loadProducts () { next() }
</pre>

<p>
In this example, <code>userRequired</code> will be called only for the<code>order</code> action, <code>prepareBasket</code> will be called for all actions except <code>order</code>, and <code>loadProducts</code> will be called only for the <code>products</code> and <code>featuredProducts</code>methods.

</p>

<p>
Note, that the before-functions should call the global <code>next</code> method that will pass control to the next function in the chain.

</p>

</section>

<section id="controllers-common-execution-context">
<h2>Common execution context</h2>

<p>
There is one extra feature in flow control: All functions are invoked in the same context, so you can pass data between the functions using the <code>this</code> object:

</p>

<pre class="prettyprint">
function loadProducts () {
    Product.find(function (err, prds) {
        this.products = prds;
        next();
    }.bind(this));
}

action('products', function () {
    assert.ok(this.products, 'Products available here');
    render(); // also products will available in view
});
</pre>

</section>

<section id="controllers-sharing-code-across-controllers">
<h2>Sharing code across controllers</h2>

<p>
Some methods, like <code>userRequired</code> for example, can be used in different controllers. To allow cross-controller code sharing, CompoundJS provides a few methods: <code>load</code>, <code>use</code> and <code>publish</code>.

</p>

<p>
You can define <code>requireUser</code> in <code>application_controller.js</code> and call <code>publish</code> to make it accessible to all other controllers that inherit from this controller:

</p>

<code>application_controller.js</code><pre class="prettyprint">
publish('requireUser', requireUser);

function requireUser () {
  // ...
}
</pre>

<code>products_controller.js</code><pre class="prettyprint">
load('application'); // note that _controller siffix omitted
before(use('userRequired'), { only: 'products' });
</pre>

</section>

<section id="controllers-other-expressjs-features">
<h2>Other express.js features</h2>

<p>
To get familiar with CompoundJS controllers, look at a few examples available at github: <a href="https://github.com/anatoliychakkaev/railwayjs.com/blob/master/app/controllers/pages_controller.coffee "coffee controller"" target="_blank">coffee controller</a>, <a href="https://github.com/1602/router/blob/master/app/controllers/users_controller.js "javascript controller"" target="_blank">javascript controller</a>.

</p>

<p>
All other expressjs features have no global shortcuts yet, but they can still be used since <code>request</code> (alias  <code>req</code>) and <code>response</code> (alias <code>res</code>) are available as global variables inside the controller context. In the view context, they are available as <code>request</code> and <code>response</code>.

</p>

</section>

<section id="views-views">
<h1>Views</h1>

</section>

<section id="views-templating-engines">
<h2>Templating engines</h2>

<p>
By default, CompoundJS uses <code>ejs</code>, but <code>jade</code> is also supported and can easily be enabled:

</p>

<code>environment/development.js</code><pre class="prettyprint">
app.set('view engine', 'jade')
</pre>

<code>npmfile.js</code><pre class="prettyprint">
require('jade-ext');
</pre>

</section>

<section id="views-view-rendering-flow">
<h2>View rendering flow</h2>

<p>
Every controller action can call the <code>render</code> method to display its associated view. For example, the<code>index</code> action of the<code>users</code> controller will render the view <code>app/views/users/index.ejs</code>.

</p>

<p>
This view will be rendered within the layout specified using the <code>layout</code> call in the controller. By default, the layout name is the same as the controller name, in this case <code>app/views/layouts/users_layout.ejs</code>. If this layout file does not exists, the <code>application</code> layout used.

</p>

<p>
If you need to render a view without a layout, you can call <code>layout(false) </code>inside of the controller, this will skip layout rendering.

</p>

</section>

<section id="views-built_in-helpers">
<h2>Built-in helpers</h2>

</section>

<section id="views-linkto">
<h3>linkTo</h3>

<pre class="prettyprint">
linkTo('Users index', '/users');
// &lt;a href="/users"&gt;Users index&lt;/a&gt;
linkTo('Users index', '/users', { class: 'menu-item' });
// &lt;a href="/users" class="menu-item"&gt;Users index&lt;/a&gt;
linkTo('Users index', '/users', { remote: true });
// &lt;a href="/users" data-remote="true"&gt;Users index&lt;/a&gt;
</pre>

<ul>
<li>First argument is the link text</li>
<li>Second argument is the link path / url</li>
<li>Third argument is an object with additional link options</li>
</ul>
<p>
In the last example, the third argument is <code>{ remote: true }</code>, and as you can see it will add a <code>data-remote="true"</code> attribute to the <code>a</code> tag. Clicking on this link will send an asynchronous <code>GET</code> request to <code>/users</code>. The result will be executed as Javascript.

</p>

<p>
Here you can also specify a <code>jsonp</code> parameter to handle the response:

</p>

<pre class="prettyprint">
linkTo('Users index', '/users', { remote: true, jsonp: 'renderUsers' });
// &lt;a href="/users" data-remote="true" data-jsonp="renderUsers"&gt;Users index&lt;/a&gt;
</pre>

<p>
The server will send you a json<code>{ users: [ {}, {}, {} ] }</code>, and this object will be passed as an argument to the <code>renderUsers</code> function:

</p>

<pre class="prettyprint">
renderUsers({users: [{},{},{}]});
</pre>

<p>
You can also specify an anonymous function in the <code> </code>jsonp param:

</p>

<pre class="prettyprint">
{ jsonp: '(function (url) { location.href = url; })' }
</pre>

<p>
When server will send you <code>"http://google.com/"</code> following javascript will be evaluated:

</p>

<pre class="prettyprint">
(function (url) { location.href = url; })("http://google.com");
</pre>

</section>

<section id="views-formfor">
<h3>formFor</h3>

<p>
Accepts two params: <code>resource</code>, <code>params</code> and returns a form helper with the following helper functions:

</p>

<ul>
<li>`begin` - opening `&lt;form&gt;` tag</li>
<li>`end` - closing `&lt;form&gt;` tag</li>
<li>`input`</li>
<li>`label`</li>
<li>`textarea`</li>
<li>`submit`</li>
<li>`checkbox`</li>
</ul>
<p>
An example:

</p>

<pre class="prettyprint">
&lt;% var form = formFor(user, { action: path_to.users }); %&gt;
&lt;%- form.begin() %&gt;

&lt;%- form.label('name', 'Username') %&gt; &lt;%- form.input('name') %&gt;
&lt;%- form.submit('Save') %&gt;

&lt;%- form.end() %&gt;
</pre>

<p>
This will generate:

</p>

<pre class="prettyprint">
&lt;form action="/users/1" method="POST"&gt;
  &lt;input type="hidden" name="_method" value="PUT" /&gt;
  &lt;input type="hidden" name="authenticity_token" value="RANDOM_TOKEN" /&gt;
  &lt;p&gt;
    &lt;label for="name"&gt;Username&lt;/label&gt;
    &lt;input id="name" name="name" value="Anatoliy" /&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;input type="submit" value="Save" /&gt;
  &lt;/p&gt;        
&lt;/form&gt;
</pre>

</section>

<section id="views-formtag">
<h3>formTag</h3>

<p>
This is the "light" version of the <code>formFor</code> helper which expects only one argument: <code>params</code>. Use this helper when you don't have a resource, but still want to be able to use simple method overriding and csrf protection tokens.

</p>

<p>
An example:

</p>

<pre class="prettyprint">
&lt;% var form = formTag({ action: path_to.users }); %&gt;
&lt;%- form.begin() %&gt;

&lt;%- form.label('name', 'Username') %&gt; &lt;%- form.input('name') %&gt;
&lt;%- form.submit('Save') %&gt;

&lt;%- form.end() %&gt;
</pre>

<p>
This will generate:

</p>

<pre class="prettyprint">
&lt;form action="/users" method="POST"&gt;
  &lt;input type="hidden" name="authenticity_token" value="RANDOM_TOKEN" /&gt;
  &lt;p&gt;
    &lt;label for="name"&gt;Username&lt;/label&gt;
    &lt;input id="name" name="name" value="" /&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;input type="submit" value="Save" /&gt;
  &lt;/p&gt;        
&lt;/form&gt;
</pre>

</section>

<section id="views-inputtag--forminput">
<h3>input_tag / form.input</h3>

<p>
TODO: describe this

</p>

</section>

<section id="views-labeltag--formlabel">
<h3>label_tag / form.label</h3>

<p>
TODO: describe this

</p>

</section>

<section id="views-stylesheetlinktag">
<h3>stylesheet_link_tag</h3>

<pre class="prettyprint">
&lt;%- stylesheetLinkTag('reset', 'style', 'mobile') %&gt;
</pre>

<p>
will generate

</p>

<pre class="prettyprint">
&lt;link media="screen" rel="stylesheet" type="text/css" href="/stylesheets/reset.css?1306993455523" /&gt;
&lt;link media="screen" rel="stylesheet" type="text/css" href="/stylesheets/style.css?1306993455523" /&gt;
</pre>

<p>
Timestamps like  <code>?1306993455524</code> are added to assets only in development mode in order to prevent the browser from caching scripts and stylesheets

</p>

</section>

<section id="views-javascriptlinktag">
<h3>javascript_link_tag</h3>

<pre class="prettyprint">
&lt;%- javascript_include_tag(
  'https://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js',
  'rails', 'application') %&gt;
</pre>

<p>
will generate

</p>

<pre class="prettyprint">
&lt;script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"&gt;&lt;/script&gt; 
&lt;script type="text/javascript" src="/javascripts/rails.js?1306993455524"&gt;&lt;/script&gt; 
&lt;script type="text/javascript" src="/javascripts/application.js?1306993455524"&gt;&lt;/script&gt;
</pre>

<p>
Timestamps like  <code>?1306993455524</code> are added to assets only in development mode in order to prevent the browser from caching scripts and stylesheets

</p>

<p>
By default, CompoundJS expects assets to be located in <code>public/javascripts</code> and<code>public/stylesheets</code> directories, but this settings can be overwritten in <code>config/environment.js</code>:

</p>

<pre class="prettyprint">
app.set('jsDirectory', '/js/');
app.set('cssDirectory', '/css/');
</pre>

</section>

<section id="views-defining-your-own-helpers">
<h2>Defining your own helpers</h2>

<p>
You can define your own helpers for each controller in the file <code>app/helpers/_controllername__helpers.js</code>. For example, if you want to define a helper called <code>my_helper</code> to use it in the <code>users</code> controller, put the following in <code>app/helpers/users_controller.js</code>:

</p>

<pre class="prettyprint">
module.exports = {
  my_helper: function () {
    return "This is my helper!";
  }
}
</pre>

<p>
The function <code>my_helper</code> can be now used by any of the views used by the <code>users</code> controller.

</p>

</section>

<section id="orm-models">
<h1>Models</h1>

<p>
By default models managed using [JugglingDB
ORM](https://github.com/1602/jugglingdb), but you can use any ORM you like. For
example, if you prefer <a href="http://mongoosejs.com" target="_blank">mongoose</a>, check [mongoose on
compound](https://github.com/anatoliychakkaev/mongoose-compound-example-app) example app.

</p>

</section>

<section id="orm-setup-db-configdatabasejs">
<h2>Setup DB: config/database.js</h2>

<p>
Describe which database adapter you are going to use and how to connect with the database in <code>config/database.js</code> (<code>.coffee</code>, <code>.json</code> and <code>.yml</code> are also supported):

</p>

<pre class="prettyprint">
module.exports = {
  development:
  { driver:   "redis"
  , host:     "localhost"
  , port:     6379
  }
, test:
  { driver:   "memory"
  }
, staging:
  { driver:   "mongodb"
  , url:      "mongodb://localhost/test"
  }
, "production":
  { driver:   "mysql"
  , host:     "localhost"
  , post:     3306
  , database: "nodeapp-production"
  , username: "nodeapp-prod"
  , password: "t0ps3cr3t"
  }
}
</pre>

<p>
Checkout the list of available adapters <a href="http://github.com/1602/jugglingdb "here"" target="_blank">here</a>. You can also specify the the adapter in the <code>schema</code> file using the<code>schema</code> method:

</p>

<pre class="prettyprint">
schema 'redis', url: process.env.REDISTOGO_URL, -&gt;
    define 'User'
    # other definitions for redis schema

schema 'mongodb', url: process.env.MONGOHQ_URL, -&gt;
    define 'Post'
    # other definitions for mongoose schema
</pre>

<p>
All of these schemas can be used simultaneously and you can even describe relations between different schemas, for example <code>User.hasMany(Post)</code>

</p>

</section>

<section id="orm-define-schema-dbschemajs">
<h2>Define schema: db/schema.js</h2>

<p>
Use <code>define</code> to describe database entities and <code>property</code> to specify types of fields. This method accepts the following arguments:

</p>

<ul>
<li>Name of property</li>
<li>Property type: Date, Number, Boolean, Text, String (default)</li>
<li>Property options: Object `{ default: 'default value', index: 'true' }`</li>
</ul>
<p>
JavaScript:

</p>

<code>db/schema.js</code><pre class="prettyprint">
var Person = define('Person', function () {
    property('email', { index: true });
    property('active', Boolean, { default: true });
    property('createdAt', Date);
});

var Book = define('Book', function () {
    property('title');
    property('ISBN');
});
</pre>

<p>
CoffeeScript:

</p>

<code>db/schema.coffee</code><pre class="prettyprint">
Person = define 'Person', -&gt;
    property 'email', index: true
    property 'active', Boolean, default: true
    property 'createdAt', Date, default: Date
    property 'bio', Text
    property 'name'

Book = define 'Book', -&gt;
    property 'title'
    property 'ISBN'
</pre>

<p>
or define a <code>custom schema</code> (non-juggling), fo example <code>mongoose</code>. Please note that in case of a custom schema, JugglingDB features will not work.

</p>

<pre class="prettyprint">
customSchema(function () {
    var mongoose = require('mongoose');
    mongoose.connect('mongodb://localhost/test');

    var Schema = mongoose.Schema, ObjectId = Schema.ObjectId;

    var BlogPost = new Schema({
        author    : ObjectId
        , title     : String
        , body      : String
        , date      : Date
    });

    var Post = mongoose.model('BlogPost', BlogPost);
    Post.modelName = 'BlogPost'; // this is for some features inside compound (helpers, etc)

    module.exports['BlogPost'] = Post;
});
</pre>

</section>

<section id="orm-implement-appmodelsname">
<h2>Implement: app/models/name</h2>

</section>

<section id="orm-describe-models">
<h3>Describe models</h3>

<p>
Models should be described in <code>app/models/modelname.js</code> files. Each model file
should export function, which accepts two arguments:

</p>

<pre class="prettyprint">
module.exports = function(compound, ModelName) {

  ModelName.classMethod = function classMethod() {
    return 'hello from class method';
  };

  ModelName.prototype.instanceMethod = function instanceMethod() {
    return 'hello from instance method';
  };
};
</pre>

<p>
If you need initialize database-independent model in model file, disregard
second param of exported function, use this example:

</p>

<pre class="prettyprint">
module.exports = function(compound) {
  // define class
  function MyModel() {
    this.prop = '';
  }

  MyModel.prototype.method = function() {};

  // register model in compound
  compound.models.MyModel = MyModel;

  // optionally specify modelname (used in view helpers)
  MyModel.className = 'MyModel';
};
</pre>

</section>

<section id="orm-describe-relations">
<h3>Describe relations</h3>

<p>
Currently, only a few relations are supported: <code>hasMany</code>and <code>belongsTo</code>

</p>

<pre class="prettyprint">
User.hasMany(Post,   {as: 'posts',  foreignKey: 'userId'});
// creates instance methods:
// user.posts(conds)
// user.posts.build(data) // like new Post({userId: user.id});
// user.posts.create(data) // build and save
// user.posts.find

Post.belongsTo(User, {as: 'author', foreignKey: 'userId'});
// creates instance methods:
// post.author(callback) -- getter when called with function
// post.author() -- sync getter when called without params
// post.author(user) -- setter when called with object
</pre>

<p>
It's also possible to use scopes inside hasMany associations, for example if you have a scope for <code>Post</code>:

</p>

<pre class="prettyprint">
Post.scope('published', { published: true });
</pre>

<p>
&nbsp;Which is just a shortcut for the <code>all</code> method:

</p>

<pre class="prettyprint">
Post.published(cb); // same as Post.all({ published: true });
</pre>

<p>
So you can use it with an association:

</p>

<pre class="prettyprint">
user.posts.published(cb); // same as Post.all({ published: true, userId: user.id });
</pre>

</section>

<section id="orm-setup-validations">
<h3>Setup validations</h3>

<p>
Validations invoked after <code>create</code>, <code>save</code> and <code>updateAttributes</code> can also be skipped when using <code>save</code>:

</p>

<pre class="prettyprint">
obj.save({ validate: false });
</pre>

<p>
Validations can be called manually by calling <code>isValid()</code> on the object.

</p>

<p>
After the validations are called, the validated object contains an <code>errors</code> hash containing error message arrays:

</p>

<pre class="prettyprint">
{
    email: [
        'can\'t be blank',
        'format is invalid'
    ],
    password: [ 'too short' ]
}
</pre>

<p>
If you want your validations to raise exceptions, just call <code>save</code> like this:

</p>

<pre class="prettyprint">
obj.save({ throws: save });
</pre>

<p>
To define a validation, call its configurator on your model's class:

</p>

<pre class="prettyprint">
Person.validatesPresenceOf('email', 'name');
Person.validatesLengthOf('password', { min: 5 });
</pre>

<p>
Each configurator accepts a set of string arguments and an optional last argument representing the settings for the validation. Here are some common options:

</p>

<ul>
<li>`if`</li>
<li>`unless`</li>
<li>`message`</li>
<li>`allowNull`</li>
<li>`allowBlank`</li>
</ul>
<p>
<code>if</code> and <code>unless</code> can be strings or functions returning a boolean that defines whether a validation is being called. The functions are invoked in the resource context which means that you can access the resource properties using <code>this.propertyName</code>.

</p>

<p>
<code>message</code> allows you to define an error message that is being displayed when the validation fails.

</p>

</section>

<section id="orm-available-validators">
<h2>Available validators</h2>

</section>

<section id="orm-length">
<h3>length</h3>

<pre class="prettyprint">
User.validatesLengthOf 'password', min: 3, max: 10, allowNull: true
User.validatesLengthOf 'state', is: 2, allowBlank: true
user = new User validAttributes

user.password = 'qw'
test.ok not user.isValid(), 'Invalid: too short'
test.equal user.errors.password[0], 'too short'

user.password = '12345678901'
test.ok not user.isValid(), 'Invalid: too long'
test.equal user.errors.password[0], 'too long'

user.password = 'hello'
test.ok user.isValid(), 'Valid with value'
test.ok not user.errors

user.password = null
test.ok user.isValid(), 'Valid without value'
test.ok not user.errors

user.state = 'Texas'
test.ok not user.isValid(), 'Invalid state'
test.equal user.errors.state[0], 'length is wrong'

user.state = 'TX'
test.ok user.isValid(), 'Valid with value of state'
test.ok not user.errors
</pre>

</section>

<section id="orm-numericality">
<h3>numericality</h3>

<pre class="prettyprint">
User.validatesNumericalityOf 'age', int: true
user = new User validAttributes

user.age = '26'
test.ok not user.isValid(), 'User is not valid: not a number'
test.equal user.errors.age[0], 'is not a number'

user.age = 26.1
test.ok not user.isValid(), 'User is not valid: not integer'
test.equal user.errors.age[0], 'is not an integer'

user.age = 26
test.ok user.isValid(), 'User valid: integer age'
test.ok not user.errors
</pre>

</section>

<section id="orm-inclusion">
<h3>inclusion</h3>

<pre class="prettyprint">
User.validatesInclusionOf 'gender', in: ['male', 'female']
user = new User validAttributes

user.gender = 'any'
test.ok not user.isValid()
test.equal user.errors.gender[0], 'is not included in the list'

user.gender = 'female'
test.ok user.isValid()

user.gender = 'male'
test.ok user.isValid()

user.gender = 'man'
test.ok not user.isValid()
test.equal user.errors.gender[0], 'is not included in the list'
</pre>

</section>

<section id="orm-exclusion">
<h3>exclusion</h3>

<pre class="prettyprint">
User.validatesExclusionOf 'domain', in: ['www', 'admin']
user = new User validAttributes

user.domain = 'www'
test.ok not user.isValid()
test.equal user.errors.domain[0], 'is reserved'

user.domain = 'my'
test.ok user.isValid()
</pre>

</section>

<section id="orm-format">
<h3>format</h3>

<pre class="prettyprint">
User.validatesFormatOf 'email', with: /^([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$/i
user = new User validAttributes

user.email = 'invalid email'
test.ok not user.isValid()

user.email = 'valid@email.tld'
test.ok user.isValid()
</pre>

</section>

<section id="orm-models-reloading">
<h2>Models reloading</h2>

<p>
In development env models automatically reloaded on file changing. If you don't
need this behavior and prefer restart webserver you can turn off this setting in
<code>config/environments/development.js</code>:

</p>

<pre class="prettyprint">
app.disable('watch');
</pre>

<p>
It also disables controllers reloading.
</p>

</section>

<section id="repl-repl-console">
<h1>REPL console</h1>

<p>
To run the REPL console use this command:

</p>

<pre class="prettyprint">
compound console
</pre>

<p>
or its shortcut:

</p>

<pre class="prettyprint">
compound c
</pre>

<p>
The REPL console is   just a simple Node.js console with some CompoundJS, for example models.

</p>

<p>
Just one note on working with the console: Node.js is asynchronous by its nature which makes console debugging much more compilcated, since you have to use a callback to fetch results from the database for instance. We have added one useful method to simplify asynchronous debugging using the REPL console. It's called <code>c</code> and you can pass it as a parameter to any function that requires a callback. It will store the parameters passed to the callback to variables called <code>_0, _1, ..., _N</code> where N is the length of <code>arguments</code>.

</p>

<p>
Example:

</p>

<pre class="prettyprint">
compound c
compound&gt; User.find(53, c)
Callback called with 2 arguments:
_0 = null
_1 = [object Object]
compound&gt; _1
{ email: [Getter/Setter],
  password: [Getter/Setter],
  activationCode: [Getter/Setter],
  activated: [Getter/Setter],
  forcePassChange: [Getter/Setter],
  isAdmin: [Getter/Setter],
  id: [Getter/Setter] }
</pre>

</section>

<section id="localization-localization">
<h1>Localization</h1>

<p>
Basic steps:

</p>

<ul>
<li>Create dictionary to translate tokens into natural language (`config/locales/*.yml`)</li>
<li>Use tokens instead of natural language everywhere in your app (`t` helper)</li>
<li>Manually detect language for each request (`setLocale` method)</li>
</ul>
<p>
CompoundJS allows you to create localized applications: Just place a <code>YAML</code>-formatted file to <code>config/locales</code> directory:

</p>

<code>config/locales/en.yml</code><pre class="prettyprint">
en:
  session:
    new: "Sign in"
    destroy: "Sign out"
  user:
    new: "Sign up"
    destroy: "Cancel my account"
    welcome: "Hello %, howdy?
    validation:
      name: "Username required"
</pre>

<p>
NOTE: Translations can contain <code>%</code> symbol(s) for variable substitution.

</p>

<p>
Define a user locale before filter to your application controller:

</p>

<code>app/controllers/application_controller.js</code><pre class="prettyprint">
before(setUserLocale);
function setUserLocale () {
    // define locale from user settings, or from headers or use default
    var locale = req.user ? req.user.locale : 'en';
    // call global function setLocale
    setLocale(locale);
}
</pre>

<p>
And use localized tokens inside your app views using the <code>t</code> helper:

</p>

<pre class="prettyprint">
&lt;%= t('session.new') %&gt;
&lt;%= t('user.new') %&gt;
&lt;%= t(['user.welcome', user.name]) %&gt;
</pre>

<p>
You can also use the <code>t</code> helper in controllers:

</p>

<pre class="prettyprint">
flash('error', t('user.validation.name'));
</pre>

<p>
or in models:

</p>

<pre class="prettyprint">
return t('email.activate', 'en')
</pre>

<p>
NOTE: When you use the <code>t</code> helper in models, you have to pass the <code>locale</code> as the second parameter.

</p>

</section>

<section id="localization-configuration">
<h2>Configuration</h2>

<p>
Localization behavior can be configured using the following settings:

</p>

<ul>
<li>`defaultLocale`: Default locale name</li>
<li>`translationMissing`: Defines what action to perform when translation is missing. Possible Values:<ul>
<li>`default` - Display translation for default locale</li>
<li>`display` - Show an error like "Translation missing for email.activate"</li>
</ul></li>
<li>`default` - Display translation for default locale</li>
<li>`display` - Show an error like "Translation missing for email.activate"</li>
</ul>
<p>
Example:

</p>

<pre class="prettyprint">
app.configure(function () {
    app.set('defaultLocale', 'en');
});

app.configure('development', function(){
    app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));
    app.set('translationMissing', 'display');
});

app.configure('production', function () {
    app.use(express.errorHandler()); 
    app.set('translationMissing', 'default');
});
</pre>

</section>

<section id="generators-generators">
<h1>Generators</h1>

<p>
CompoundJS generators are automated tools that allow you to create a bunch of files automatically. Each generator can be run via:

</p>

<pre class="prettyprint">
compound generate GENERATOR_NAME
</pre>

<p>
or using the shortcut:

</p>

<pre class="prettyprint">
compound g GENERATOR_NAME
</pre>

<p>
Built-in generators are:<code>model</code>, <code>controller</code>, <code>scaffold</code> (alias: <code>crud</code>)

</p>

</section>

<section id="generators-generate-model">
<h2>Generate model</h2>

<p>
Use case: You just need a model and schema.

</p>

<p>
Example:

</p>

<pre class="prettyprint">
compound g model user email password approved:boolean
</pre>

<p>
Generated files:

</p>

<pre class="prettyprint">
exists  app/
exists  app/models/
create  app/models/user.js
patch   db/schema.js
</pre>

<p>
The generated model file contains the following code:

</p>

<pre class="prettyprint">
module.exports = function (compound, User) {
  // define User here
};
</pre>

<p>
The patched schema file contains the following code:

</p>

<pre class="prettyprint">
var User = describe('User', function () {
    property('email', String);
    property('password', String);
    property('approved', Boolean);
});
</pre>

</section>

<section id="generators-generate-controller">
<h2>Generate controller</h2>

<p>
Use case: You don't need a standard RESTful controller, just a few non-standard actions.

</p>

<p>
Example:

</p>

<pre class="prettyprint">
compound g controller controllername actionName otherActionName
</pre>

<p>
Generated files:

</p>

<pre class="prettyprint">
exists  app/
exists  app/controllers/
create  app/controllers/controllername_controller.js
exists  app/helpers/
create  app/helpers/controllername_helper.js
exists  app/views/
create  app/views/controllername/
create  app/views/controllername/actionName.ejs
create  app/views/controllername/anotherActionName.ejs
</pre>

<p>
The generated controller file contains the following code:

</p>

<pre class="prettyprint">
load('application');

action("actionName", function () {
    render();
});

action("anotherActionName", function () {
    render();
});
</pre>

</section>

<section id="generators-generate-scaffold-crud">
<h2>Generate scaffold (crud)</h2>

<p>
The most commonly used generator. It creates a ready-to-use resource controller with all needed actions, views, schema definitions, routes and tests. Compound can also generate scaffolds in CoffeeScript.

</p>

<p>
Example call:

</p>

<pre class="prettyprint">
compound g scaffold post title content createdAt:date
exists  app/
exists  app/models/
create  app/models/post.js
exists  app/
exists  app/controllers/
create  app/controllers/posts_controller.js
exists  app/helpers/
create  app/helpers/posts_helper.js
create  app/views/layouts/posts_layout.ejs
create  public/stylesheets/scaffold.css
exists  app/views/
create  app/views/posts/
create  app/views/posts/_form.ejs
create  app/views/posts/new.ejs
create  app/views/posts/edit.ejs
create  app/views/posts/index.ejs
create  app/views/posts/show.ejs
patch   config/routes.js
</pre>

</section>

<section id="asset-compiler-asset-compiler">
<h1>Asset Compiler</h1>

</section>

<section id="asset-compiler-included-compilers">
<h2>Included Compilers</h2>

<ul>
<li>coffee (default for js)</li>
<li>less</li>
<li>sass</li>
<li>stylus (default for css)</li>
</ul>
</section>

<section id="asset-compiler-basic-usage">
<h2>Basic Usage</h2>

<p>
Environment Settings:

</p>

<p>
in <code>/config/environment.js</code>
use the AssetCompiler middleware and set you css engine

</p>

<pre class="prettyprint">
...
app.configure(function(){
  app.use(compound.assetsCompiler.init());
  ...
  app.set('cssEngine', 'stylus');
  ...
});
...
</pre>

<p>
This will compile stylus (or whatever you use as you css engine) files in
<code>/app/assets/stylesheets</code> into <code>/public/stylesheets</code> and <code>/app/assets/coffeescripts</code> into <code>/public/javascripts</code>

</p>

</section>

<section id="asset-compiler-configuration">
<h2>Configuration</h2>

<p>
Configuration can be done either in an initializer or in the Environment file.

</p>

<p>
Compilers should be configured using the <code>compound.assetCompiler.config(compilerName, options)</code> method.
This method takes 2 params, the name of the compiler and an obje t containing the options to configure, 
and returns <code>compound.assetCompiler</code> for chaining. the default compilers use the following options:

</p>

<ul>
<li>render: a function to compile the source into js or css, see Adding Your Own Compiler for more details</li>
<li>sourceExtension: `'coffee'`</li>
<li>destExtension: `'js'`</li>
<li>sourceDir: `''` or `'/coffeescripts'`</li>
<li>destDir: `''` or `'/javascripts'`</li>
</ul>
<p>
It may also contain any other options which can be accessed in the render function ( <code>this.myCustomOption</code> )

</p>

<p>
configure the coffe compiler to look for coffe files in <code>assets/coffee</code> instead of <code>/assets/coffeescripts</code>:

</p>

<p>
<code>/config/environment.js</code>

</p>

<pre class="prettyprint">
...
app.configure(function(){
  app.use(compound.assetsCompiler.configure('coffee', {
    sourceDir: '/coffee'
  }).init());
  ...
});
...
</pre>

</section>

<section id="asset-compiler-compiler-specific-configuration">
<h2>Compiler Specific Configuration</h2>

</section>

<section id="asset-compiler-stylus">
<h3>stylus:</h3>

<p>
when using stylus you may want to use some custom configurations as described here: http://learnboost.github.com/stylus/docs/js.html

</p>

<p>
<code>/config/environment.js</code>

</p>

<pre class="prettyprint">
...
app.configure(function(){
  app.use(compound.assetsCompiler.configure('stylus', {
    use: function(stylus) {
      stylus.use(mylib);
      stylus.define('families', ['Helvetica Neue', 'Helvetica', 'sans-serif']);
      stylus.import(path);
      stylus.include(path);
    }
  }).init());
  ...
});
...
</pre>

</section>

<section id="asset-compiler-adding-your-own-compiler">
<h2>Adding Your Own Compiler</h2>

<p>
Adding your own comiler can be done using <code>compound.assetCompiler.add(compilerName, options)</code>

</p>

<p>
options should contain the following:
* render: a function to compile the source into js or css, see Adding Your Own Compiler for more details
* sourceExtension: <code>'coffee'</code>
* destExtension: <code>'js'</code>
* sourceDir: <code>''</code> or <code>'/coffeescripts'</code>
* destDir: <code>''</code> or <code>'/javascripts'</code>
* any other options your render function needs

</p>

<p>
The render function takes the 3 arguments:

</p>

<ul>
<li>src, a string containing the source of the file to be compiled</li>
<li>options: sourceDir, destDir, sourceFileName, destFileName.  shouldn't be necassary in most cases</li>
<li>callback: pass 2 arguements, error and the compiled source.</li>
</ul>
<p>
an example of how to add your own coffee compiler:

</p>

<p>
<code>/config/environment.js</code>

</p>

<pre class="prettyprint">
...
app.configure(function(){
  app.use(compound.assetsCompiler.add('coffee', {
    render: function(str, options, fn) {
      try {
        fn(null, this.coffee.compile(str));
      } catch (err) {
        fn(err);
      }
    },
    coffee: require('coffee-script'),
    sourceDir: '/coffeescripts',
    destDir: '/javascripts',
    sourceExtension: 'coffee',
    destExtension: 'js'
  }).init());
  ...
});
...
</pre>

</section>

<section id="extension-api-compound-api">
<h1>Compound API</h1>

<p>
This chapter describes internal API of compound application. Compound app designed
as npm module that can be used as part of other modules.

</p>

<p>
Main entry point called <code>server.js</code> exports function for creating application.
This function returns regular express application with one addition: <code>compound</code>
object. This is object we are talking about. It contains some information about
application, such as root directory path, MVC structure, models. Read this
chapter to get familiar with this powerful tool.

</p>

</section>

<section id="extension-api-compound-app">
<h2>Compound app</h2>

<p>
Let's start with the entry point, called <code>server.js</code> by default. If you want to
rename it, update package.json with <code>"main": "server.js"</code> line. The purpose of that
file: publish function that  creates application. This function can create many
instances of application which could be configured and used separately:

</p>

<pre class="prettyprint">
// load package
var instantiateApp = require('.');

// create different instances
var app1 = instantiateApp();
var app2 = instantiateApp(params);

// run on different ports/hosts
app1.listen(3000);
app2.listen(3001, '10.0.0.2', callback);
</pre>

<p>
Instantiation method accepts optional hash of params. These params hash will be
passed to express.

</p>

</section>

<section id="extension-api-tools">
<h3>Tools</h3>

<p>
The <code>compound.tools</code> hash contains commands that can be invoked using the command line, for example <code>compound routes</code> will call <code>compound.tools.routes()</code> .

</p>

<p>
To write a tool, just add another method to the <code>compound.tools</code> object, the method name will become the command name:

</p>

<pre class="prettyprint">
compound.tools.database = function () {
    switch (compound.args.shift()) {
    case 'clean':
        // clean db
        break;
    case 'backup':
        // backup db
        break;
    case 'restore':
        // restore db
        break;
    default:
        console.log('Usage: compound database [clean|backup|restore]');
    }
};
</pre>

<p>
Then the following commands will be available:

</p>

<pre class="prettyprint">
compound database
compound database backup
compound database clean
compound database restore
</pre>

<p>
If you want to see this command when using <code>compound help</code>you can provide some information about the tool using the <code>help</code>hash:

</p>

<pre class="prettyprint">
compound.tools.db.help = {
    shortcut: 'db',
    usage: 'database [backup|restore|clean]',
    description: 'Some database features'
};
</pre>

<p>
The next time you call <code>compound</code>, you will see:

</p>

<pre class="prettyprint">
Commands:
  ...
  db, database [backup|restore|clean]  Some database features
</pre>

<p>
If you defined a shortcut, it can be used instead of the full command name:

</p>

<pre class="prettyprint">
compound db clean
</pre>

<p>
To learn more, please check out <a href="https://github.com/1602/compound/blob/master/lib/tools.js "the sources"" target="_blank">the sources</a>: <code>lib/tools.js</code>

</p>

</section>

<section id="extension-api-generators">
<h3>Generators</h3>

<p>
Coming soon. It's about the <code>compound.generators</code> module and the <code>compound generate</code> commands.

</p>

</section>

<section id="extension-api-structure">
<h3>Structure</h3>

<p>
Coming soon. This chapter about compound.structure api, overwriting internals of
compound app without touching source code.

</p>

</section>

<section id="extension-api-extensions">
<h1>Extensions</h1>

<p>
Any npm package can be used as an extension for CompoundJS. If it should be
loaded at compound app startup, it should export <code>init</code> method. This method will
receive single argument: compound app.

</p>

<p>
Compound will initialize each extension listed in <code>config/autoload.js</code> file.
Example of file generated on <code>compound init</code> command:

</p>

<pre class="prettyprint">
module.exports = function(compound) {
    return [
        require('ejs-ext'),
        require('jugglingdb'),
        require('seedjs')
    ];
};
</pre>

<p>
We are trying to keep compound core tiny, some parts of framework now moved to
separate modules:

</p>

<ul>
<li>railway-routes</li>
<li>jugglingdb</li>
<li>kontroller</li>
<li>seedjs</li>
</ul>
<p>
Some of the modules still loaded from core, but in future everything will be
moved to <code>config/autoload</code>. It means that every part of compound can be replaced
with another module that should follow common API.

</p>

</section>

<section id="heroku-heroku">
<h1>Heroku</h1>

<p>
Heroku's Node.js hosting is available fo public usage now. Deploying a CompoundJS application is as simple as <code>git push</code>.

</p>

<p>
To work with heroku you also need <code>ruby</code> as well as the <code>heroku</code> gem.

</p>

</section>

<section id="heroku-deploying-an-application">
<h3>Deploying an application</h3>

<p>
First of all, create an application:

</p>

<pre class="prettyprint">
compound init heroku-app
cd heroku-app
sudo npm link
compound g crud post title content
</pre>

<p>
Then initialize a git repository:

</p>

<pre class="prettyprint">
git init
git add .
git commit -m 'Init'
</pre>

<p>
Create a Heroku application:

</p>

<pre class="prettyprint">
heroku create --stack cedar
</pre>

<p>
Want to use MongoDB?

</p>

<pre class="prettyprint">
heroku addons:add mongohq:free
</pre>

<p>
Want to use Redis?

</p>

<pre class="prettyprint">
heroku addons:add redistogo:nano
</pre>

<p>
And deploy:

</p>

<pre class="prettyprint">
git push heroku master
</pre>

<p>
Hook up Procfile (only once):

</p>

<pre class="prettyprint">
heroku ps:scale web=1
</pre>

<p>
Check application state:

</p>

<pre class="prettyprint">
heroku ps
</pre>

<p>
Visit your application:

</p>

<pre class="prettyprint">
heroku open
</pre>

<p>
If something went wrong, you can check out the logs:

</p>

<pre class="prettyprint">
heroku logs
</pre>

<p>
To access the CompoundJS REPL console, do:

</p>

<pre class="prettyprint">
heroku run compound console
</pre>

<p>
MongoHQ provides a web interface for browsing your MongoDB database, to use it go to <code>http://mongohq.com/</code>, create an account, then click "Add remote connection" and configure the link to your database. You can retrieve defails required for the connection using this command:

</p>

<pre class="prettyprint">
heroku config --long
</pre>

</section>

<section id="code-snippets-code-snippets">
<h1>Code snippets</h1>

</section>

<section id="code-snippets-multiple-workers-compound-server-node-0816">
<h2>Multiple workers compound server (node 0.8.16)</h2>

<p>
Example in CoffeeScript:

</p>

<code>server.coffee</code><pre class="prettyprint">
#!/usr/bin/env coffee

app = module.exports = (params) -&gt;
  params = params || {}
  # specify current dir as default root of server
  params.root = params.root || __dirname
  return require('compound').createServer(params)

cluster = require('cluster')
numCPUs = require('os').cpus().length

if not module.parent
  port = process.env.PORT || 3000
  host = process.env.HOST || "0.0.0.0"
  server = app()
  if cluster.isMaster
    # Fork workers.
    cluster.fork() for i in [1..numCPUs]

    cluster.on 'exit', (worker, code, signal) -&gt;
      console.log 'worker ' + worker.process.pid + ' died'
  else
    server.listen port, host, -&gt;
      console.log(
        "Compound server listening on %s:%d within %s environment",
        host, port, server.set('env'))
</pre>

</section>

<section id="code-snippets-redis-session-store-for-heroku-deployment-with-redistogo-addon">
<h2>Redis session store for Heroku deployment with redistogo addon</h2>

<p>
Hook the <code>REDISTOGO_URL</code> environment variable in <code>config/environment.js</code> and pass it to the RedisStore constructor.
Example in CoffeeScript:

</p>

<pre class="prettyprint">

module.exports = (compound) -&gt;

  express = require 'express'
  RedisStore = require('connect-redis')(express)

  if process.env['REDISTOGO_URL']
    url = require('url').parse(process.env['REDISTOGO_URL'])
    redisOpts =
      port: url.port
      host: url.hostname
      pass: url.auth.split(':')[1]
  else
    redisOpts = {}

  app.configure -&gt;
    app.use compound.assetsCompiler.init()
    app.set 'view engine', 'ejs'
    app.set 'view options', complexNames: true
    app.enable 'coffee'

    app.set 'cssEngine', 'stylus'

    app.use express.static(app.root + '/public', {maxAge: 86400000})
    app.use express.bodyParser()
    app.use express.cookieParser()
    app.use express.session secret: 'secret', store: new RedisStore(redisOpts)
    app.use express.methodOverride()
    app.use app.router
</pre>

</section>

<section id="code-snippets-upload-file-to-compound-server">
<h2>Upload file to compound server</h2>

<ul>
<li><a href="http://groups.google.com/group/railwayjs/browse_thread/thread/592df72830898e9a" target="_blank">Discussion in Google Groups</a></li>
<li>The solution is to use <a href="https://github.com/anatoliychakkaev/connect-form-sync" target="_blank">this middleware</a></li>
<li>Check out <a href="https://github.com/anatoliychakkaev/railway-example-upload" target="_blank">example app</a></li>
</ul>
<pre class="prettyprint">
var form = require('connect-form-sync');
app.configure(function(){
    ....
    app.use(form({ keepExtensions: true }));
    app.use(express.bodyParser());
    ....
});
</pre>

<p>
And use it in the controller like that:

</p>

<pre class="prettyprint">
action('create', function () {
    this.file = new File();
    var tmpFile = req.form.files.file;
    this.file.upload(tmpFile.name, tmpFile.path, function (err) {
        if (err) {
            console.log(err);
            this.title = 'New file';
            flash('error', 'File can not be created');
            render('new');
        } else {
            flash('info', 'File created');
            redirect(path_to.files);
        }
    }.bind(this));
});
</pre>

<p>
Documentation is maintained by <a href="http://twitter.com/1602" target="_blank">@1602 (Anatoliy Chakkaev)</a> and <a href="http://twitter.com/rattazong" target="_blank">@rattazong (Sascha Gehlich)</a>.

</p>

<p>
CompoundJS is licensed under the <a href="http://www.opensource.org/licenses/mit-license.php" target="_blank">MIT License</a>. Documentation is licensed under <a href="http://creativecommons.org/licenses/by/3.0/" target="_blank">CC BY 3.0</a>.

</p>

<p>
The CompoundJS and JugglingDB projects are free, but you can leave a tip here:

</p>

<form style="text-align: center" action="https://www.paypal.com/cgi-bin/webscr" method="post">
  <input type="hidden" name="cmd" value="_s-xclick">
  <input type="hidden" name="hosted_button_id" value="J3JJDYJW78LEJ">
  <input type="image" style="box-shadow: none; -webkit-box-shadow: none; padding: 0; border: 0; width: 147px; height: 47px;" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
  <img alt="" border="0" src="https://www.paypalobjects.com/ru_RU/i/scr/pixel.gif" width="1" height="1">
</form></section>
    </div>
  </body>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23280347-1']);
  _gaq.push(['_setDomainName', 'none']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);

  (function() {
   var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
   })();

</script>
</html>
